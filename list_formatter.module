<?php

/**
 * @file
 * Provide a field formatter to render values as HTML or comma-separated lists.
 */

use Drupal\list_formatter\Plugin\field\formatter\ListFormatter;
use Drupal\Core\Template\Attribute;

/**
 * Implements hook_help().
 */
function list_formatter_help($path, $arg) {
  switch ($path) {
    case 'admin/help#list_formatter' :
      $output =  '<p>' . t("The text formatter module provides a new display formatter that can
        be used on any text, number, list, or taxonomy fields.") . '</p>';
      $output .= '<p>' . t("Go to 'Manage display' for your entity field display settings and
        select 'List' as the formatter. Various options will then be available to either format
        your field values as an html list or comma separated list.") . '</p>';
      $output .= '<p>' . t("This would be mostly implemented with multi value fields.
        E.g. A text field could be created with unlimited values. Each value will then be added to
        the same html list. Taxonomy terms will work with comma separated auto complete lists too,
        to give the same result. The only exceptions are textarea field, lists can be created based
        on each line of the input.") . '</p>';

    return $output;
  }
}

/**
 * Implements hook_field_formatter_info_alter().
 */
function list_formatter_field_formatter_info_alter(&$info) {
  $list_formatter_info = ListFormatter::prepareFieldListInfo();

  $info['list_formatter']['field_types'] = $list_formatter_info['fields'];
  $info['list_formatter']['settings']['contrib'] = $list_formatter_info['settings'];
}

/**
 * Implements hook_theme().
 */
function list_formatter_theme($existing, $type, $theme, $path) {
  return array(
    'list_formatter_comma' => array(
      'variables' => array(
        'items' => NULL,
        'formatter' => NULL,
        'attributes' => NULL
      ),
    ),
  );
}

/**
 * Implements hook_list_formatter_field_info().
 */
function list_formatter_list_formatter_field_info() {
  $info = array();

  $info['text'] = array(
    'fields' => array('text', 'text_long', 'text_with_summary'),
    'callback' => 'list_formatter_text_field_create_list',
  );
  $info['number'] = array(
    'fields' => array('number_integer', 'number_decimal', 'number_float'),
  );
  $info['list'] = array(
    'fields' => array('list_float', 'list_integer', 'list_text'),
    'callback' => 'list_formatter_list_field_create_list',
  );
  $info['taxonomy'] = array(
    'fields' => array('taxonomy_term_reference'),
    'callback' => 'list_formatter_taxonomy_field_create_list',
  );

  return $info;
}

/**
 * Create list for text fields.
 */
function list_formatter_text_field_create_list($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $settings = $display['settings'];
  $list_items = array();

  if ($field['type'] == 'text_long') {
    foreach ($items as $delta => $item) {
      // Explode on new line char, trim whitespace (if any), then array filter (So any empty lines will actually be removed).
      $long_text_items = array_filter(array_map('trim', explode("\n", $item['value'])));
      foreach ($long_text_items as $long_text_item) {
        // @see _text_sanitize(), text.module
        $list_items[] = ($instance['settings']['text_processing'] ? check_markup($long_text_item, $item['format'], $langcode) : field_filter_xss($long_text_item));
      }
    }
  }
  else {
    foreach ($items as $delta => $item) {
      $list_items[] = ($instance['settings']['text_processing'] ? check_markup($item['value'], $item['format'], $langcode) : field_filter_xss($item['value']));
    }
  }

  return $list_items;
}

/**
 * Create list for list fields.
 */
function list_formatter_list_field_create_list($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $settings = $display['settings'];
  $list_items = array();

  // Get allowed values for the field.
  $allowed_values = list_allowed_values($field);
  foreach ($items as $delta => $item) {
    if (isset($allowed_values[$item['value']])) {
      $list_items[$delta] = field_filter_xss($allowed_values[$item['value']]);
    }
  }

  return $list_items;
}

/**
 * Create list for taxonomy reference fields.
 */
function list_formatter_taxonomy_field_create_list($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $settings = $display['settings'];
  $list_items = $tids = array();

  // Get an array of tids only.
  foreach ($items as $item) {
    $tids[] = $item['tid'];
  }

  $terms = taxonomy_term_load_multiple($tids);

  foreach ($items as $delta => $item) {
    // Check the term for this item has actually been loaded.
    // @see http://drupal.org/node/1281114
    if (empty($terms[$item['tid']])) {
      continue;
    }
    // Use the item name if autocreating, as there won't be a term object yet.
    $term_name = ($item['tid'] === 'autocreate') ? $item['name'] : $terms[$item['tid']]->name;
    // Check if we should display as term links or not.
    if ($settings['term_plain'] || ($item['tid'] === 'autocreate')) {
      $list_items[$delta] = check_plain($term_name);
    }
    else {
      $uri = $terms[$item['tid']]->uri();
      $list_items[$delta] = l($term_name, $uri['path']);
    }
  }

  return $list_items;
}

/**
 * Validate that a space-separated list of values are lowercase and appropriate
 * for use as HTML classes.
 *
 * @see list_formatter_field_formatter_settings_form()
 */
function _list_formatter_validate_class($element, &$form_state) {
  $value = drupal_array_get_nested_value($form_state['values'], $element['#parents']);
  $classes = explode(' ', $value);
  foreach ($classes as $class) {
    if ($class != drupal_html_class($class)) {
      form_error($element, t('List classes contain illegal characters; classes should be lowercase and may contain letters, numbers, and dashes.'));
      return;
    }
  }
}

/**
 * Helper to return the value key for a field instance.
 *
 * @param $field array
 *  The whole array of field instance info provided by the field api.
 *
 * @return string
 *  The value key for the field.
 */
function _list_formatter_get_field_value_key(array $field) {
  return (array_key_exists('columns', $field) && is_array($field['columns'])) ? key($field['columns']) : 'value';
}

/**
 * Theme function to render comma separated lists.
 */
function theme_list_formatter_comma($variables) {
  $items = $variables['items'];
  $formatter = $variables['formatter'];
  $attributes = new Attribute($variables['attributes']);

  // Optionally prefix the last item with 'and'.
  $last = '';
  if ($formatter->getSetting('comma_and') && (count($items) > 1) && !$formatter->getSetting('comma_override')) {
    $last = ' ' . t('and') . ' ' . array_pop($items);
  }

  // Default comma separator.
  $separator = ', ';
  //Override if we need to.
  if ($formatter->getSetting('comma_override')) {
    $sep = check_plain($formatter->getSetting('separator_custom'));
    $tag = $settings['separator_custom_tag'];
    if ($tag) {
      $class = $formatter->getSetting('separator_custom_class');
      $separator = "<$tag class=\"$class\">$sep</$tag>";
    }
  }
  // Generate a comma-separated list.
  $output = implode($separator, $items) . $last;

  // Optionally follow the list with a '.'.
  if ($formatter->getSetting('comma_full_stop')) {
    $output .= '<span class="list_formatter-fullstop">.</span>';
  }

  // Optionally wrap the list in an HTML tag.
  $tag = $formatter->getSetting('comma_tag');
  if ($tag) {
    $output = "<$tag$attributes>$output</$tag>";
  }

  return $output;
}
